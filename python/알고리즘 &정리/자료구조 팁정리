인접 행렬
-모든 노드와 그에대한 비용을 행렬로 표현한것
-장점 : 어떤 노드와 어떤 노드가 연결되어있는지 바로 확인하기가 좋음
-단점 : 굳이 연결되지않은 노드의 정보 모두 가지고있어서 메모리 효율성이 떨어짐
인접리스트
-서로 연결된 노드만을 저장하고있음
-장점 : 메모리 효율성이 좋다(불필요한 정보들은 포함하지않음)
-단점 : 어떤 노드들이 서로 연결되어있는지 알아보는데 시간이걸림

BFS(깊이 우선 탐색)
-스택구조 & 재귀함수 사용
-탐색 수행에 O(n) 
-가장 멀리있는 노드부터 탐색

DFS(너비 우선 탐색)
-가장 가까운 노드부터 탐색
-큐 구조 사용

선택정렬
-가장 원시적인방법으로 남아있는 값중 가장 작은값을 골라 맨앞으로 보내는 정렬
-시간복잡도는 O(n^2)

삽입정렬
-두번째 원소부터 자신의 왼쪽은 무조건 정렬되어있다고 가정하고 자신의 자리를 찾아 넣는 정렬
-데이터가 거의다 정렬되어있을떄 효율적이다(최선의경우 O(n))
-시간복잡도는 O(n^2)

퀵정렬
-피벗을 사용하여 그보다 큰것은 왼쪽 작은것은 오른쪽에서부터 탐색하여 두값을 교환하고 피벗은 그 둘이 엇갈렸을경우 작은값과 교환한다
-맨처음 원소를 피벗으로 설정하는것이 호어분할방식이다
-항상 시간복잡도O(nlogn)
-'이미 정렬되어있는 경우' 매우 느리게 동작하여 최악의경우 O(n^2)까지 발생

계수정렬
-'특정조건'이 부합할때만 사용가능한 매우빠른 정렬 알고리즘이다
-모든 데이터가 양수이고 갯수는 N 데이터 최댓값이 K일때 , 최악의경우에도 
O(N+K) 보장한다
-조건 : 데이터의 크기범위가 제한되어 정수형태로 표현할 수 있을때
-조건이 있는 이유는 모든 범위를 담을 수 있는 크기의 리스트를 선언해야되기 때문이다

순차탐색
-리스트안에 있는 특정한 데이터를 찾기위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법
-시간복잡도는 O(N)

이진탐색
-배열 내부의 데이터가 정렬되어있을 경우만 사용가능한 알고리즘
-찾으려는 데이터와 중간점 위치에있는 데이터를 반복적으로 비교해서 원하는 데이터를 찾는 알고리즘
-시간복잡도는 O(logN)

신장트리
-하나의 그래프가 있을때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프이다